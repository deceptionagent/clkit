CLKit - nice things for command-line tools


The classes in CLKit provide simple ways for command-line tools to define verbs and options, as well
as how input to options is interpreted.

Below is a tour of CLKit's pieces.

CLKVerb
Instances of this class define a single verb by name (e.g., the "compare" part of `tmutil compare`)
and a block to be executed when the user invokes the verb. The block receives the portion of argv
to the right of the verb. This reduced argv can be passed directly to CLKOptArgParser.

CLKVerbDepot
A very simple class that acts as a lookup table for defined verbs.

CLKOption
The model that defines an option (e.g., --foo) for a verb. Options always have a long form (name)
and a short form (flag). Options can require arguments ("payload options") or be options that do
not take an argument ("free options"). Payload options are simply referred to as options by APIs.

CLKOptArgParser
This class does the work of parsing an argument vector and interpreting it using a list of options.
The resulting manifest is used to determine your program's behavior.

CLKOptArgManifest
Generated by CLKOptArgParser, this packages up the results of option parsing. It includes:

	- a dictionary of free options detailing the number of times those options were provided
	- a dictionary of option arguments detailing the input that was provided to payload options		
	- positional "remainder" arguments that weren't associated with options

Given this argument vector:

	--foo --foo --bar --alpha hello.txt --alpha world.txt --bravo updog.txt /tmp/out.txt

The resulting manifest would look like:
	
	// free options
	{
		"foo" : 1,
		"bar" : 3
	}
	
	// option arguments
	{
		"alpha" : [
			"hello.txt",
			"world.txt"
		],
	
		"bravo" : [
			"lorem_ipsum.txt"
		]
	}
	
	// remainder arguments
	[
		"/tmp/out.txt"
	]

CLKArgumentTransformer
Option arguments are interpreted as strings by default, but tools often have options whose arguments
are other types of data such as numbers. An argument transfomer can be set on a payload option in
order to translate the input string during parsing. Some useful transformers are provided by CLKit.

Using a transformer looks like this:

	[Option optionWithName:@"foo" flag:@"f" transformer:[CLKIntegerArgumentTransformer transformer]];

That's it. After parsing, the "foo" key in the manifest's option arguments dictionary would
contain an array of NSNumbers instead of NSStrings.

You can subclass CLKArgumentTransformer to support other kinds of automatic transformation.
