CLKit - nice things for command-line tools


The classes in CLKit provide simple ways for command-line tools to define verbs and options, as well
as how input to options is interpreted.

Below is a tour of CLKit's pieces.

CLKVerb
Instances of this class define a single verb by name (e.g., the "compare" part of `tmutil compare`)
and a block to be executed when the user invokes the verb. The block receives the portion of argv
to the right of the verb. This reduced argv can be passed directly to CLKArgumentParser.

CLKVerbDepot
A very simple class that acts as a lookup table for defined verbs.

CLKOption
The model that defines an option (e.g., --foo) for a verb. Options always have a long form (name)
and optionally a short form (flag). Options can require arguments ("parameter options") or be options
that do not take an argument ("switch options").

A parameter option can be required, meaning it must be present in the argument vector or CLKArgumentParser
will automatically error. All options can have a list of dependencies, which are parameter options that
are required if the option is present. (E.g., "--foo requires --bar, but --bar is not required on its own.")

CLKArgumentParser
This class does the work of parsing an argument vector and interpreting it using a list of options.
The resulting manifest is used to determine your program's behavior.

CLKArgumentManifest
Generated by instances of CLKArgumentParser, this packages up the results of parsing:

	- the number of times switch options were provided
    - arguments that were provided to parameter options
	- positional arguments that weren't associated with options

Given this argument vector:

	--foo --foo --bar --alpha hello.txt --alpha world.txt --bravo updog.txt /tmp/out.txt

The resulting manifest would look like:
	
	// subscriptable keys
	{
        // switch option accumulation counts
		"foo" : 1,
		"bar" : 3,

        // parameter option arguments
		"alpha" : [
			"hello.txt",
			"world.txt"
		],

		"bravo" : [
			"lorem_ipsum.txt"
		]
	}
	
	// positional arguments
	[
		"/tmp/out.txt"
	]

You would access the data in the manifest like so:

    NSUInteger fooLevel = manifest[@"foo"].unsignedIntegerValue;

    for (NSString *alphaFileName in manifest[@"alpha"]) {
        // do something with alphaFileName
    }

CLKArgumentTransformer
Option arguments are interpreted as strings by default, but tools often have options whose arguments
are other types of data such as numbers. An argument transfomer can be set on a parameter option in
order to translate the input string during parsing. Some useful transformers are provided by CLKit.

Using a transformer looks like this:

	[Option parameterOptionWithName:@"foo" flag:@"f" transformer:[CLKIntegerArgumentTransformer transformer]];

That's it. After parsing, the "foo" key in the manifest's option arguments dictionary would
contain an array of NSNumbers instead of NSStrings.

You can subclass CLKArgumentTransformer to support other kinds of automatic transformation.
